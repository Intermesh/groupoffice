<?php

namespace go\modules\community\maildomains\model;

use DateTimeInterface;
use go\core\acl\model\AclOwnerEntity;
use go\core\db\Criteria;
use go\core\orm\Filters;
use go\core\orm\Mapping;
use go\core\orm\Query;
use go\core\util\ArrayObject;
use go\modules\community\maildomains\util\DnsCheck;

final class Domain extends AclOwnerEntity
{

	public ?string $id;
	public ?string $userId;
	public string $domain;
	public string|null $description;

	/**
	 * Maximum number of aliases
	 */
	public int $maxAliases = 0;

	/**
	 * Maximum number of mailboxes
	 *
	 * @var int
	 */
	public int $maxMailboxes = 0;


	/**
	 * Max assignable quota in bytes
	 */
	public float $totalQuota = 0;

	/**
	 * Default quota in bytes
	 */
	public float $defaultQuota = 0;

	public string $transport;
	public bool $backupMx = false;
	public ?int $createdBy;
	public ?DateTimeInterface $createdAt;
	public int $modifiedBy;
	public ?DateTimeInterface $modifiedAt;

	/** @var boolean */
	public bool $active = true;

	public ?string $spf;

	public $spfStatus;

	public $mx;

	public $mxStatus;

	public $dmarc;

	public $dmarcStatus;
	public $dkim;

	/**
	 * Used quota in bytes
	 */
	public ?float $sumUsedQuota;

	/**
	 * Disk usage in bytes
	 */
	public ?float $sumUsage;

	public bool $checkDNS = false;

	/**
	 * @inheritDoc
	 */
	protected static function defineMapping(): Mapping
	{
		return parent::defineMapping()
			->addTable('community_maildomains_domain', 'cmd')
			->addQuery(
				(new Query())
					->select('CAST(SUM(`cmm`.`quota`) AS SIGNED) as `sumUsedQuota`, CAST(SUM(`cmm`.`bytes`) AS SIGNED) as `sumUsage`')
				->join('community_maildomains_mailbox', 'cmm', '`cmd`.`id`=`cmm`.`domainId`', 'LEFT')
				->groupBy(['`cmd`.`id`']))
			->addMap('dkim', DkimKey::class, ['id' => 'domainId']);
	}

	/**
	 * Prevent conflict with the old Postfix Admin module
	 *
	 * @return string
	 */
	public static function getClientName(): string
	{
		return "MailDomain";
	}

	/**
	 * @inheritDoc
	 */
	protected static function defineFilters(): Filters
	{
		return parent::defineFilters()
			->add('id', function (Criteria $criteria, $value) {
				if (!empty($value)) {
					$criteria->where(['id' => $value]);
				}
			})
			->add('active', function (Criteria $criteria, $value) {
				$criteria->where(['active' => $value]);
			});
	}

	public function countMailboxes(): int {
		return go()->getDbConnection()
			->selectSingleValue('count(*)')
			->from("community_maildomains_mailbox")
			->where("domainId", "=", $this->id)
			->single();
	}

	public function countAliases(): int {
		return go()->getDbConnection()
			->selectSingleValue('count(*)')
			->from("community_maildomains_alias")
			->from("community_maildomains_alias")
			->where("domainId", "=", $this->id)
			->single();
	}


	/**
	 * @inheritDoc
	 */
	protected static function textFilterColumns(): array
	{
		return ['description', 'domain'];
	}

	/**
	 * @inheritDoc
	 */
	public function title(): string
	{
		return $this->id;
	}

	public function getSumUsedQuota(): float
	{
		return $this->sumUsedQuota ?? 0;
	}

	public function getSumUsage(): float
	{
		return $this->sumUsage;
	}



	protected function internalSave(): bool
	{

		if($this->checkDNS) {
			$this->checkDns();
		}

		return parent::internalSave(); // TODO: Change the autogenerated stub
	}


	public function checkDns(): void
	{
		$ip = gethostbyname(Settings::get()->getMailHost()); //Request::get()->getHost());
		$dnsChecker = new DnsCheck($this, $ip);
		$r = $dnsChecker->checkAll();
		$this->updateDns($r);
	}


	/**
	 * Upon manually checking DNS settings, update the domain record and DkimKey records as per DNS checks
	 *
	 * @param ArrayObject $record
	 * @throws \Exception
	 */
	public function updateDns(ArrayObject $record): void
	{
		$this->mxStatus = $record['mx'];
		$this->mx = implode(", ", $record['mxTargets']);
		$this->spf = $record['spf'];
		$this->spfStatus = $record['spfStatus'];
		$this->dmarc = $record['dmarc']['raw'] ?? null;
		$this->dmarcStatus = !empty($record['dmarc']);

		foreach($record['dkim'] as $selector => $dnsKey) {
			$storedKey = $this->dkim[$selector]->parsePublicKey();
			$this->dkim[$selector]->status = $dnsKey && ($storedKey == $dnsKey['p']);
		}
	}
}